- js type은 primitive type / object(reference) type으로 나뉜다.
- 원시 값 : Immutable value, 객체(참조) 타입의 값, 즉 객체는 mutable value.
- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 객체를 변수에 할당하면 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 복사되어 전달된다. (pass by value) 객체를 가리키는 변수를 다른 변수에 할당하면 참조 값이 복사되어 전달된다. (pass by reference)
### 11.1 원시 값
#### 11.1.1 변경 불가능한 값
 - 한 번 생성된 원시값은 읽기 전용으로, 변경할 수 없다.
	 - 이는 데이터의 신뢰성을 보장한다.
 - 변수가 아니라 >>>값<<< 에 대한 것임에 주의한다. 즉 메모리에 실제 저장된 데이터이다. 변수는 재할당을 통해 변경을 할 수 있다!
 - 상수는 재할당이 금지된 변수일 뿐이므로 immutable value와 동일시 해서는 안된다.
- 변수에 값이 재할당되면, 새로운 메모리 공간이 확보되고 그 곳에 값을 저장한 후 변수가 그 메모리 주소를 가리킨다.
- 이 특성을 **불변성 immutability** 라고 한다.
- 재할당 외에 변수 값을 변경할 수 있는 방법이 없다. 만약 변경 가능 값이었다면 변수 값이 예기치않게 변경될 수 있고, 값의 변경 (상태 변경)의 추적이 어려워진다.

#### 11.1.2 문자열과 불변성
- 원시 값 저장을 위해서는 확보할 메모리 크기를 결정 해야하고, 타입별 메모리 공간의 크기는 미리 정해져있다.
- ECMAScript : string 2byte, number 8byte만 정의해놓음. 다른 원시타입은 엔진 제조사마다 다를 수 있다.
- 문자열은 0개 이상의 문장로 이루어진 집합을 말한다. 하나의 문자는 2바이트에 저장된다. 길이에 따라 필요한 공간이 달라진다.
- 이런 특성 때문에 C는 char만 있고 문자열을 배열로 처리한다. 자바는 String 객체로 처리한다.
- 하지만 자바스크립트의 String은 원시 타입이고 변경 불가능하다.
- 문자열은 유사 배열 객체이며 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.
> 유사 배열 객체란
> 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있으며 length 프로퍼티를 갖는다. for로 순회 가능
> 객체인 이유는 객체처럼 사용할 시 원시 값을 감싸는 래퍼 객체로 자동 변환되기 때문이다.

```js
var str = 'string';

// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
// 하지만 문자열은 원시값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.
str[0] = 'S';

console.log(str); // string
```
- 에러는 없고, 변경도 안된다. 예기치않은 변경을 막을 수 있다.
- 물론 완전 재할당은 가능함

#### 11.1.3 값에 의한 전달
```js
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy);  // 80

score = 100;

console.log(score); // 100
console.log(copy);  // ?
```

여기서 copy는 어떻게 될 것인가? 
copy는 그대로 80이지! 복사됐으니까

- 변수에 변수를 할당했을 때 무엇이 전달되는가? -> score의 평가값이 전달됨.
- 즉 80이 새로 생성되어 copy에 전달된다.
- score와 copy는 다른 메모리 공간에 저장된 별개의 값이다.
- score 를 변경하면 새로 메모리 할당이 이루어지고, copy에는 영향이 없다.
- MDN: 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사된다고 설명한다.
- 하지만 변수 할당 시점에서는 같은 원시값을 참조하다가, 재할당이 이루어지면 새 메모리를 가리키도록 동작할 수도 있다. (Python)

- pass by value는 ECMAScript에는 없는 용어로, 다른 언어에서 자주 사용하는 언어다.
- 엄격히 표현하면 변수에는 메모리 주소가 전달되기 때문에 값이 전달되지는 않는다.
- 즉 식별자는 메모리 주소를 기억하고 있다. 메모리 주소에 붙인 이름이랄까,,

**두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한 쪽에서 재할당을 통해 값을 변경하더라고 서로 간섭할 수 없다.**


### 11.2 객체
- 프로퍼티의 개수는 정해져있지 않고, 동적으로 추가 및 삭제가 가능하다. 프로퍼티 값에도 제약이 없다.
- 원시 값처럼 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다.

>  js 객체 관리 방식
>  프로퍼티 키를 인덱스로 상룡하는 hash table(associative array, map, dictionary, lookup table이라고도 함)이라고 생각할 수 있다. 대부분의 js엔진은 해시테이블과 유사하게, 더 나은 방식으로 구현한다.
>  java, c++(클래스 기반)은 객체 생성 이전에 클래스가 정의되어 있어 프로퍼티, 메서드가 정해져있고 그대로 객체로 생성한다. 객체 생성 이후에는 프로퍼티 변경이 불가능하다.
>  js는 클래스 없이 생성이 되고, 객체 생성 이후에도 동적으로 프로퍼티와 메서드 추가가 가능하다. 사용에는 편리하지만, 생성 및 프로퍼티 접근데 비용이 많이 든다.
>  따라서 V8에서는 동적 탐색 dynamic lookup 대신 히든 클래스 hidden class를 사용해 C++ 객체 프로퍼티 접근하는 정도의 성능을 보장한다. 히든클래스는 자바 객체 레이아웃 등과 유사하게 동작한다.
>  https://engineering.linecorp.com/ko/blog/v8-hidden-class

#### 11.2.1 변경 가능한 값
- 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값 mutable value 이다.
- 객체 할당한 변수가 기억하는 메모리 주소로 메모리 공간에 접근하면 참조 값 reference value에 접근할 수 있다. (주소 그 자체)
```js
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: 'Lee'
};

// person 변수에 저장되어 있는 참조값으로 실제 객체에 접근해서 그 객체를 반환한다.
console.log(person); // {name: "Lee"}
```

- person은 객체 {name: 'Lee'} 를 가리키고 잇따.

- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.
- 프로퍼티 동적 추가, 프로퍼티 값 갱신, 프로퍼티 삭제가 가능하다.
- 변경 가능 값이므로 수정해도 재할당이 아니고, 참조 값은 변경되지 않는다.
	- 변수에 저장된 메모리주소는 똑같고, 그 주소에 저장된 실제 값이 변경됨.
- 크기가 일정하지도 않고, 매우 클 수 있어서 deep copy 하면 메모리 효율적 소비가 어렵고 성능이 나빠진다.
- 즉 성능을 위해 변경 가능한 값으로 설계되었다.
- 부작용은 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. 근데 이건 다른 언어도 다 비슷하잖아

#### 11.2.2 참조에 의한 전달
- 여러 개의 식별자가 하나의 객체를 공유하는 게 무엇인가?

```js
var person = {
  name: 'Lee'
};

// 참조값을 복사(얕은 복사). copy와 person은 동일한 참조값을 갖는다.
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

// person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```

- copy에 person을 학당하면 person 참조값을 복사한다. 즉 동일한 참조 값을 가리키므로, 같은 객체를 가리킨다.
- 한 쪽에서 객체를 변경하면 서로 영향을 받는다.
- 값에 의한 전달과는 메모리 공간에 저장된 값이 복사된다는 점이 똑같은데, 이 경우는 참조 값이므로 같은 객체를 가리킬 뿐이다. 즉 값에 의한 전달만 존재한다고 볼 수 있다.
- 이거 대신 "공유에 의한 전달" 이라고 표현하기도 한다. (call by sharing)
- pointer와 이 책의 참조에 의한 전달이 다름에 주의!!!

```js
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // ①
console.log(person1.name === person2.name); // ②
```

요걸 예측해보자.
1 -> false. (주소값)
2 -> true (name은 primitive 이기 때문임)


### 의문점
#### pass by reference (pointer가 있는 언어)와 js의 객체 shallow copy는 뭐가 다른가? java와의 차이는?
- C++에서 call by reference 하고 재할당 받을 경우, 해당 메모리의 값이 아예 바뀐다.
	- &a 로 매개변수 넘겨받거나, `int *p = &a;` `*p = 10;` 할 경우, a의 값이 아예 바뀜.
- js및 java에서 참조 변수에 **재할당하면 새 메모리가 생성되지, 기존 메모리의 값이 바뀌지 않는다**
- property를 변경하면 공유된 메모리가 변경되는 것이기 때문에 복사된 변수가 영향을 받는다는 점은 동일하다.

✔️ JavaScript와 Java는 참조값을 값으로 전달하는 방식(call by sharing)이라, **객체 내부 변경은 가능하지만, 새로운 객체를 할당하면 원본과 연결이 끊어짐.**  
✔️ C++에서는 **참조(&)나 포인터를 사용하면 원본을 직접 변경 가능!**  
✔️ C++의 포인터를 활용하면, **이중 포인터(double pointer)로 포인터 자체를 변경할 수도 있음!**  
✔️ **Java와 JavaScript는 call by reference가 아니지만, C++의 포인터는 call by reference처럼 동작 가능!**

| 개념            | JavaScript (Call by Sharing) | Java (Call by Value, but with reference values) | C++ (Call by Reference) |
| ------------- | ---------------------------- | ----------------------------------------------- | ----------------------- |
| 전달 방식         | 참조 값(메모리 주소)을 복사             | 참조 값(메모리 주소)을 복사                                | 원본 변수 자체의 별칭(alias)     |
| 내부 변경 시 원본 영향 | ✅ (변경됨)                      | ✅ (변경됨)                                         | ✅ (변경됨)                 |
| 새로운 객체 할당 시   | ❌ (원본 변경 안 됨)                | ❌ (원본 변경 안 됨)                                   | ✅ (원본 변경됨)              |
