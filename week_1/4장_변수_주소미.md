# 4장: 변수

<br>

## 4.1 변수(variable)

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 <br>

변수명: 메모리 공간에 저장된 값을 식별할 수 있는 이름

- 할당(assignment): 변수에 값을 저장하는 것
- 참조(reference): 변수에 저장된 값을 읽어 들이는 것

<br>

## 4.2 식별자(identifier)

어떤 값을 구별해서 식별할 수 있는 고유한 이름, 식별자는 값이 아니라 메모리 주소를 기억한다.
<br>

모든 변수는 식별자이지만, 모든 식별자가 변수는 아니다.
식별자는 주소를 기억 → 그 주소로 저장된 값에 접근

변수, 함수, 클래스 등의 이름은 모두 식별자. 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

<br>

## 4.3 변수 선언(variable declaration)

값을 저장하기 위해 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것 <br>
변수 선언에 의해 확보된 메모리 공간은 해제되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없게끔 보호된다.

변수를 선언하려면 `var`, `let`, `const`키워드를 사용하여 선언한다.

### `var`키워드

- **`var`키워드는 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다.**

```
function test() {
  if (true) {
    var x = 5;
  }
  console.log(x); // 5 (블록 무시)
}
```

자바스크립트 엔진은 2단계에 걸쳐서 수행된다.

- 선언 단계: 이름을 등록해서 JS 엔진에 변수의 존재를 알림
- 초기화 단계: 값을 저장하기 위한 메모리 공간 확보, 암묵적으로 `undefined`를 할당해 초기화

`var`키워드의 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. <br>

- 장점: 쓰레기 값이 나오지 않는다.

  <br>

#### 실행 콘텍스트(execution context)

변수 이름을 비롯한 모든 식별자가 등록된다. JS 엔진이 소스코드를 평가하고 실행하기 위한 필요한 환경을 제공, 코드의 실행 결과를 실제로 관리하는 영역

<br>

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```
console.log(score); // undefined

var score; // 변수 선언
```

`ReferenceError`가 발생해야 할 것 같지만, `undefined`가 출력된다.

#### 변수 호이스팅

변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유 특징 <br>
모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문에 발생한다.

- 런타임 : 소스코드가 한 줄 씩 순차적으로 실행되는 시점
- 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내서 먼저 실행 -> 소스코드의 평가 과정이 끝나면 비로소 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 읽어 실행한다!

## 4.5 값의 할당

변수 선언은 소스 코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, **값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에서 실행된다.**
<br>

```
console.log(score); // undefined

var score = 80; // 변수 선언 + 값의 할당

console.log(score); // 80
```

단축 표현을 해도 변수 선언과 값의 할당을 2개의 문으로 각각 나누어서 실행한다. <br>
변수에 값을 할당할 때 이전 `undefined`가 저장된 메모리 공간을 지우고 새로 80을 저장하는 것이 아니다. 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장한다.

<br>

## 4.6 값의 재할당

`var` 키워드로 선언한 변수의 값은 재할당할 수 있다. <br>
엄밀히 말하면 선언과 동시에 `undefined`로 초기화되기 때문에 변수에 처음으로 값을 할당하는 것도 재할당이라고 할 수 있다.
<br>
재할당된 후, 이전의 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. (메모리에서 언제 해제될지는 예측할 수 없다.)

**상수(const)** : 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없음, 단 한 번만 할당 가능

<br>

- **Unmanaged Language**: 개발자가 명시적으로 메모리를 할당, 해제하기 위해 메모리 제어 기능을 제공 <br>

  - C의 `malloc()`, `free()`
  - 개발자의 역량에 따라 성능 확보 but 오류 가능성

- **Managed Language**: 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않음.
  - 성능 면에서 어느 정도의 손실 발생 가능 (GC 과정 및 자동 메모리 회수 과정이 원인)

<br>

## 4.7 식별자 네이밍 규칙

- 식별자는 특수문자 제외 문자, 숫자, `_`, `$`를 포함할 수 있다.
- 단 식별자는 특수 문자를 제외한 문자, `_`, `$`로 시작해야 한다. 숫자로 시작해서는 안된다.
- 예약어는 식별자로 사용할 수 없다.

## <br>

## 호이스팅 비교 (`let` vs. `var` vs. `const`)

`let/const`의 경우 TDZ로 인해 참조 불가 에러가 발생하게 된다.

```
console.log(a); // undefined (호이스팅 O)
var a = 10;

console.log(b); // ReferenceError (호이스팅 O, TDZ)
let b = 20;
```

#### TDZ(Temporal Dead Zone)

선언 위치까지 메모리 공간이 확보되지만 접근이 차단, 엔진이 `아직 초기화되지 않은 변수` 를 감지하면 에러가 발생한다.

<br>

### 왜 `var` 대신 `const`, `let`을 쓰는 것이 더 좋은 것일까?

- `var`: 함수 레벨 스코프
- `const`, `let`: 블록 레벨 스코프 지원

```
// var: 블록 무시
if (true) {
  var a = 10;
}
console.log(a); // 10 (의도치 않은 누수)

// let/const: 블록 내에서만 유효
if (true) {
  let b = 20;
  const c = 30;
}
console.log(b); // ReferenceError
console.log(c); // ReferenceError
```

#### 재할당 방지

```
var count = 10;
var count = 20; // No error, but original value is lost

let count = 1;
let count = 2; // ❌ SyntaxError
```

<br>

### 결론: `var`를 버려야 하는 상황

- 블록 스코프가 필요한 상황
- 변수 재선언/재할당 방지가 필요한 경우

  <br>

### 호이스팅을 막으려면 어떻게 해야하는가?

호이스팅은 JS 엔진 내부 동작 방식의 필수적인 부분이라 완전히 막을 수 없다. 모든 선언문은 런타임 이전에 실행 컨텍스트에 등록되기 때문이다.

그렇다면 호이스팅으로 인한 예기치 않은 동작을 줄이려면?

> `let`과 `const`를 사용하면 변수 선언만 호이스팅되고 초기화는 코드 실행 시점에 이루어지므로, 선언 전에 접근하면 ReferenceError가 발생한다. 코드의 문제점을 조기에 발견할 수 있게 도와준다.
