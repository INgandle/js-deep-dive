#### 목차
 ▣ 04장: 변수  
4.1 변수란 무엇인가? 왜 필요한가?  
4.2 식별자 
4.3 변수 선언  
4.4 변수 선언의 실행 시점과 변수 호이스팅  
4.5 값의 할당  
4.6 값의 재할당  
4.7 식별자 네이밍 규칙


#### 4.1 변수란 무엇인가? 왜 필요한가?
계산을 위해서는 literal, operator의 의미를 알고 있어야하고, 표현식을 해석(parsing) 할 수 있어야 한다.
 - 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.
 - 변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.
 - 개발자를 위한 문서이기도 하다.

#### 4.2 식별자
- 변수이름, 식별자, 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
- 메모리 주소와 식별자의 매핑 정보도 메모리에 저장되어야 한다.
	- 식별자는 즉 값이 아니라 메모리 주소를 기억하고 있다.
- 변수 뿐만 아니라 함수 클래스 등의 이름도 식별자다.
#### 4.3 변수 선언
- 선언을 통해 자바스크립트 엔진에 식별자의 존재를 알리고, 변수 선언이 가능하다.
- 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결한다.
- 해제 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하다.
- var, let, const로 변수를 선언할 수 있다.
	- var는 블록 레벨 스코프를 지원하지 않고, 함수 레벨 스코프를 지원하여 의도치않게 전역 변수가 선언 되는 부작용이 있다.
	- ES6에서 이를 극복하기 위해 let, const가 추가되었다.
- `var score;`로 변수를 선언하면 score가 등록되고, 해당되는 메모리에는 `undefined`라는 값이 암묵적으로 할당되어 초기화된다. (only js)
- 자바스크립트에서는 선언/초기화 두 가지의 단계를 거쳐 변수가 선언된다.

> 변수 이름은 어디에 등록되는가?
>변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 실행 컨텍스트(execution context)는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. js 엔진은 실행 컨텍스트를 통해 식별자, 스코프를 관리한다.
>변수이름, 변수값은 K-V 형태 객체로 등록되어 관리된다. 13장, 23장 참고.

- `var`는 선언, 초기화가 동시에 진행된다. 
- 선언으로 score 등록, 암묵적인 `undefined` 할당으로 초기화.
- 초기화를 거치지 않으면 쓰레기 값이 남아 있을 수 있다. `undefined`할당으로 쓰레기값 참조 위험에서 안전하다.
- 선언하지 않은 식별자에 접근하면 **ReferenceError** 가 발생한다. (js 엔진이 등록된 식별자를 찾을 수 없을 때 발생)
#### 4.4 변수 선언의 실행 시점과 변수 호이스팅
```js
console.log(score);

var scope;
```
- 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행된다. 그러나 해당 상황에는 ReferenceError가 발생하지 않는다.
- 변수 선언은 런타임이 아니라 그 이전에 먼저 실행되기 때문이다.

- js 엔진은 소스코드 실행 전 평가 과정을 거친다. 이 때 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아 먼저 실행한다. 그 이후 선언문을 제외하고 한 줄씩 순차적으로 실행한다.
- 변수 선언이 어디있든 가장 먼저 실행되고, 어디에서든 변수를 참조할 수 있다.
- 위 코드의 `console.log`는 `undefined`를 출력한다.
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅(hoisting)** 이라고 한다.
- var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅 된다. 모두 런타임 이전에 실행되기 때문이다.
#### 4.5 값의 할당
- 변수에 값을 할당 할 때는 할당 연산자를 사용한다.
```js
var score;
score = 80;

var score = 80;
```
- 두 선언문은 정확히 동일하게 동작한다.
- 후자의 경우에도 변수 선언은 런타임 이전 호이스팅되고, 할당은 런타임에 된다는 것에 주의한다. 
- 변수 출력(사용) -> 선언 -> 할당 -> 출력 하면 첫번째 출력에서는 undefined가, 두 번째 에서는 할당된 값이 나온다.
	- 이 과정에서 할당된 값은 undefined 자리에 덧씌워지는 것이 아니라, 새로운 메모리를 확보하여 그 곳에 할당된다.
- 예제
```js
console.log(score);

score = 80;
var score;

console.log(score);
```
이렇게 하면 마지막 예상값은? -> 80 예상.
선언문은 런타임 이전이지만, 할당은 런타임에 이루어지기 때문에 마지막 console.log는 실제 할당된 값인 80이 나올것이다.
![[Screenshot 2025-02-17 at 4.38.20 PM.png]]
예상과 일치하는 결과가 나왔음을 알 수 있다.

#### 4.6 값의 재할당
- `var` 키워드로 선언한 변수는 값을 재할당 할 수 있다.
- 선언과 동시에 `undefined`로 할당되므로, 엄밀히 말하면 `var a = 70;`도 재할당임.
- 값을 재할당 할 수 있으면 변수, 못하면 (ES6 - const)상수 라고 한다.
- 변수에 값을 재할당하면 재할당한 값으로 변경된다. 기존 할당된 메모리 공간을 지우는 것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 재할당한 값을 저장한다.
- 참조가 없는데 할당된 메모리 공간들은 나중에 가비지 컬렉터에 의해 해제된다. 언제 해제될지는 예측할 수 없다.
> managed language, unmanaged language
> C - 대표 언매니지드 언어. 개발자가 메모리를 할당, 제어할 수 있다. 개발자의 역량에 따라 성능을 확보할 수 있지만, 치명적인 오류가 발생할 수 있다.
> js는 매니지드 언어로, 메모리 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다. 메모리 해제는 가비지 콜렉터가 수행한다. 성능면에서 어느정도 손실이 있다.

#### 4.7 식별자 네이밍 규칙
- 특수문자 제외 문자, 숫자, _ , $
- 숫자로 시작할 수 없다.
- 예약어 제외 (break, case 등)

- ES5부터 식별자에 유니코드 문자를 허용한다. (한글 등 가능.) 비권장.
- 자바스크립트는 **대소문자를 구분한다.** 
	- firstname, FIRSTNAME은 다른 변수다.
- 주석 없이 의미가 명확해야 한다.
- 일반적으로 변수, 함수 - camelCase, 생성자 함수와 클래스 - PascalCase 를 사용한다.


### 별개의 의문점
- 변수에 값을 재할당하면 재할당한 값으로 변경된다. 기존 할당된 메모리 공간을 지우는 것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 재할당한 값을 저장한다.
=> 이거 다른 언어도 그럴까? 내가 알기로는 C는 기존 메모리 공간에 값을 덧씌우는데, 이 친구는 메모리 접근이 워낙 자유롭고, 컴파일 언어라 그런가 싶다..
가비지 컬렉터 얘기가 나오는 거로 봐서는 gc의 유무에 따라 달라질 수도 있을 것 같다. JAVA? C++은? C++은 스마트 포인터가 있는데..

| 언어             | 메모리 관리 방식        | 재할당 시 동작                   | 가비지 컬렉션    |
| -------------- | ---------------- | -------------------------- | ---------- |
| **C**          | 수동 메모리 관리        | 스택 값 덮어쓰기, 동적 메모리는 직접 해제   | ❌ 없음       |
| **C++**        | 수동/스마트 포인터 관리    | 기본 타입 덮어쓰기, 스마트 포인터는 자동 해제 | ❌ 없음 (선택적) |
| **Java**       | JVM이 자동 관리       | 기본 타입 덮어쓰기, 참조형은 새 메모리 할당  | ✅ 있음       |
| **Python**     | 인터프리터 + GC 기반 관리 | 항상 새로운 메모리 할당.             | ✅ 있음       |
| **JavaScript** | 인터프리터 + GC 기반 관리 | 항상 새로운 메모리 할당.             | ✅ 있음       |

- Python은 Primitive type도 모두 객체로 취급되므로 항상 새로운 객체가 생성된다. 그러나 Primitive / 참조형 변수가 따로 있는 Java는 후자만 새로운 메모리를 할당한다. C++은 객체 생성일 때 생성자/소멸자가 호출되어 관리한다.
- 파이썬에는 원시 타입(Primitive Type)이 존재하지 않는다. 객체에 더 중심을 둔 언어로 모든 것이 객체이다. 공식문서에 다음과 같은 말로 설명되어 있다.
> All data in a Python program is represented by objects or by relations between object.

근데 JS의 경우.. Mdn을 보면?.
> 모든 원시 값은 "불변"하여 변형할 수 없습니다. 원시 값 자체와, 원시 값을 할당한 변수를 혼동하지 않는 것이 중요합니다. 변수는 새로운 값을 다시 할당할 수 있지만, 이미 생성한 원시 값은 객체, 배열, 함수와는 달리 변형할 수 없습니다. 언어에서는 원시 값을 변경하는 기능을 제공하지 않습니다.
> 원시 값에는 메서드가 없지만 마치 메서드가 있는 것처럼 동작합니다. 원시 값에서 속성에 접근하려면, JavaScript는 값을 래퍼 객체로 "자동으로 포장"하고 대신 해당 객체 속성에 접근합니다. 예를 들어, `"foo".includes("f")`는 암시적으로 [`String`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String) 래퍼 객체를 생성하고 해당 객체에 대해 `String.prototype.includes()`를 호출합니다. 이 "자동으로 포장"은 JavaScript 코드에서 관찰할 수 없지만 다양한 동작에 대한 좋은 정신적인 모델입니다. 예를 들어, "값을 변경하는" 원시 값이 작동하지 않는 이유는 `str.foo = 1`이 `str` 자체의 `foo` 속성에 할당되지 않기 때문입니다. 하지만, 임시 래퍼 객체에는 적용됩니다.

자스는 primitive type은 따로 있고 객체가 아니다. 그리고 불변이다. 그래서 primitive type 값 재할당마다 진짜 새로운 메모리를 확보한다. 
primitive type이 불변인 이유는 ECMAScript 문서에 있고.. 설계 철학의 문제라고 한다..
##### 언어 설계와 철학

- **JavaScript**는 **동적 타입**을 지원하는 **인터프리터 언어**입니다. 즉, 변수의 타입을 **런타임에 결정**합니다. JavaScript의 설계자는 **예측 가능하고 안전한 코드를 생성하는 것**에 중점을 두었고, 원시 값이 불변이면 **값을 공유하는 코드가 실수로 변경되는 것을 방지**할 수 있기 때문에, 원시 값을 불변으로 만드는 방향으로 설계한 것입니다. 이 방식은 **안전성**과 **성능**을 고려한 결과입니다.
- **JavaScript의 불변성**은 또한 **메모리 모델**에서 중요한 역할을 합니다. 원시 값은 스택에 **값 자체를** 저장하는데, 이 값을 변경하려면 새로운 값을 **새로운 메모리 공간에 할당**해야 합니다. 이 방식은 **간단한 메모리 관리**를 가능하게 하고, **불변성**을 유지하는 것이 성능 상 유리할 수 있습니다
다른 언어들이 원시 값에 대해 불변을 강제하지 않는 이유는 언어의 설계 철학에 있습니다. **C**나 **Java**와 같은 언어에서는 **직접적인 메모리 관리**와 **타입 안정성**을 강조하고, 프로그래머가 **변수와 메모리**를 명확하게 제어할 수 있도록 합니다.

반면, **JavaScript**는 **동적 타입 언어**로, **값이 변경되지 않는 방식**으로 더 예측 가능한 결과를 도출하려는 의도가 있습니다. **불변성**을 유지하는 것이 **안전성**을 높이고, **예상치 못한 부작용**을 줄일 수 있기 때문입니다.

##### 결론

- **JavaScript**는 원시 값이 **불변**하여 **안전성**과 **성능**을 개선하고, **예측 가능한 코드**를 작성할 수 있게 돕습니다.
- **Java**, **C++**, **C**와 같은 언어는 **불변성**을 강제하지 않으며, **메모리 관리와 변수 재할당**이 **프로그래머에게 명확하게 제어**됩니다. 이들 언어는 **타입 안정성**과 **메모리 최적화**에 중점을 둡니다.

그렇다네요.. "동적 타입 언어" 이기 때문에 그렇다.